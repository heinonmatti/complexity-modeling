---
title: "El Rogier"
---

```{r setup, verbose = FALSE, warning = FALSE, message = FALSE}
source("T1_plus_T3-datasetup.R")
```


# Coupling of Autonomous motivation and BCTs

Conceptually, this model describes the mutualistic coupling of autonomous motivation to do physical activity (PA) and the use of behaviour/motivation management techniques (BCTs). 

Autonomous motivation means doing things because they are pleasurable, meaningful or fitting with one's identity.

BCTs are different techniques which help in actualising PA, as in setting goals, considering how PA fits with one's values, etc.

The variables in this code chunk are mean scores of 9 (autonomous motivation) and 19 (BCTs) items.

## Basic model

```{r aut-bct-coupling}
# The model in this script is originally part of the manuscript 
#'Developmental cognitive neuroscience using Latent Change Score models: A tutorial and applications'
#Rogier A. Kievit, Andreas M. Brandmaier, Gabriel Ziegler, Anne-Laura van Harmelen, 
#Susanne de Mooij, Michael Moutoussisa, Ian Goodyer, Ed Bullmore, Peter Jones, 
#Peter Fonagy, NSPN Consortium, Ulman Lindenberger & Raymond J. Dolan                                                         
# Code was originally written by Rogier A. Kievit (rogier.kievit@mrc-cbu.cam.ac.uk), 30 January 2017.
# It may be used, (re)shared and modified freely under a CC-BY license 

data_BLCS <- df %>% dplyr::select(
  intervention,
  Autonomous_T1 = PA_autonomous_T1,
  Autonomous_T2 = PA_autonomous_T3,
  frqbct_T1 = PA_frqbct_T1,
  frqbct_T2 = PA_frqbct_T3,
  agrbct_T1 = PA_agrbct_T1,
  agrbct_T2 = PA_agrbct_T3) %>% 
  rowwise() %>% 
  dplyr::mutate(BCTs_T1 = mean(c(frqbct_T1, agrbct_T1), na.rm = TRUE),
                BCTs_T2 = mean(c(frqbct_T2, agrbct_T2), na.rm = TRUE)) %>% 
  dplyr::select(-contains("frq"), -contains("agr"))


#Fit the Bivariate Latent Change Score model to simulated data
BLCS<-'

Autonomous_T2 ~ 1 * Autonomous_T1     # This parameter regresses Autonomous_T2 perfectly on Autonomous_T1
d_Autonomous1 =~ 1 * Autonomous_T2     # This defines the latent change score factor as measured perfectly by scores on Autonomous_T2
d_Autonomous1 ~ 1             # This estimates the intercept of the change score 
Autonomous_T1 ~  1           # This estimates the intercept of Autonomous_T1 
Autonomous_T2 ~ 0 * 1          # This constrains the intercept of Autonomous_T2 to 0

BCTs_T2 ~ 1 * BCTs_T1     # This parameter regresses BCTs_T2 perfectly on BCTs_T1
d_BCTs1 =~ 1 * BCTs_T2     # This defines the latent change score factor as measured perfectly by scores on BCTs_T2
BCTs_T2 ~ 0 * 1          # This line constrains the intercept of BCTs_T2 to 0
BCTs_T2 ~~ 0 * BCTs_T2    # This fixes the variance of the BCTs_T1 to 0  

d_Autonomous1 ~~  d_Autonomous1       # This estimates the variance of the change scores
Autonomous_T1 ~~   Autonomous_T1    # This estimates the variance of the Autonomous_T1 
Autonomous_T2 ~~ 0 * Autonomous_T2    # This fixes the variance of the Autonomous_T2 to 0  

d_BCTs1 ~ 1             # This estimates the intercept of the change score 
BCTs_T1 ~ 1            # This estimates the intercept of BCTs_T1 
d_BCTs1 ~~ d_BCTs1        # This estimates the variance of the change scores 
BCTs_T1 ~~ BCTs_T1      # This estimates the variance of BCTs_T1 

d_BCTs1 ~ Autonomous_T1 + BCTs_T1   # This estimates the COG to NEU coupling parameter and the COG to COG self-feedback
d_Autonomous1 ~ BCTs_T1 + Autonomous_T1   # This estimates the NEU to COG coupling parameter and the NEU to NEU self-feedback

Autonomous_T1 ~~ BCTs_T1     # This estimates the Autonomous_T1 BCTs_T1 covariance
d_Autonomous1 ~~ d_BCTs1          # This estimates the d_Autonomous and d_BCTs covariance
'

fitBLCS <- lavaan::lavaan(BLCS, 
                          data = data_BLCS, 
                          estimator = 'mlr', 
                          fixed.x = FALSE,
                          group = "intervention",
                          missing = 'fiml')

lavaan::summary(fitBLCS, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)

semPlot::semPaths(fitBLCS, 
                  what = "std",
                  ask = FALSE,
                  label.cex = .6, 
                  label.scale = FALSE,
                  edge.label.cex = 0.75, 
                  layout = "tree2",
                  intercepts = TRUE,
                  color = list(lat = viridis::viridis(3, begin = 0.3)[1], 
                               man = viridis::viridis(3, begin = 0.3)[2], 
                               int = viridis::viridis(3, begin = 0.3)[3]))



```

## Constrained model

Next, we constrain parameters, which ought to be the same across groups, as identical:

* the intercept of Autonomous_T1   
* the variance of the Autonomous_T1   
* the intercept of BCTs_T1  
* the variance of BCTs_T1   
* the covariance between Autonomous_T1 and BCTs_T1  

```{r}
data_BLCS <- df %>% dplyr::select(
  intervention,
  Autonomous_T1 = PA_autonomous_T1,
  Autonomous_T2 = PA_autonomous_T3,
  frqbct_T1 = PA_frqbct_T1,
  frqbct_T2 = PA_frqbct_T3,
  agrbct_T1 = PA_agrbct_T1,
  agrbct_T2 = PA_agrbct_T3) %>% 
  rowwise() %>% 
  dplyr::mutate(BCTs_T1 = mean(c(frqbct_T1, agrbct_T1), na.rm = TRUE),
                BCTs_T2 = mean(c(frqbct_T2, agrbct_T2), na.rm = TRUE)) %>% 
  dplyr::select(-contains("frq"), -contains("agr"))


#Fit the Bivariate Latent Change Score model to simulated data
BLCS_constrained <- '

Autonomous_T2 ~ 1 * Autonomous_T1     # This parameter regresses Autonomous_T2 perfectly on Autonomous_T1
d_Autonomous1 =~ 1 * Autonomous_T2    # This defines the latent change score factor as measured perfectly by scores on Autonomous_T2
d_Autonomous1 ~ 1                     # This estimates the intercept of the change score 
Autonomous_T1 ~  c(autint, autint)*1  # This constrains the intercept of Autonomous_T1 to be identical across intervention and control groups 
Autonomous_T2 ~ 0 * 1                 # This constrains the intercept of Autonomous_T2 to 0

BCTs_T2 ~ 1 * BCTs_T1     # This parameter regresses BCTs_T2 perfectly on BCTs_T1
d_BCTs1 =~ 1 * BCTs_T2    # This defines the latent change score factor as measured perfectly by scores on BCTs_T2
BCTs_T2 ~ 0 * 1           # This line constrains the intercept of BCTs_T2 to 0
BCTs_T2 ~~ 0 * BCTs_T2    # This fixes the variance of the BCTs_T1 to 0  

d_Autonomous1 ~~  d_Autonomous1                     # This estimates the variance of the change scores
Autonomous_T1 ~~ c(autvar, autvar) * Autonomous_T1  # This estimates the variance of the Autonomous_T1 
Autonomous_T2 ~~ 0 * Autonomous_T2                  # This fixes the variance of the Autonomous_T2 to 0  

d_BCTs1 ~ 1                            # This estimates the intercept of the change score 
BCTs_T1 ~ c(bctint, bctint) * 1        # This estimates the intercept of BCTs_T1 
d_BCTs1 ~~ d_BCTs1                     # This estimates the variance of the change scores 
BCTs_T1 ~~ c(bctvar, bctvar) * BCTs_T1 # This estimates the variance of BCTs_T1 

d_BCTs1 ~ Autonomous_T1 + BCTs_T1       # This estimates the COG to NEU coupling parameter and the COG to COG self-feedback
d_Autonomous1 ~ BCTs_T1 + Autonomous_T1 # This estimates the NEU to COG coupling parameter and the NEU to NEU self-feedback

Autonomous_T1 ~~ c(autbct_cov, autbct_cov) * BCTs_T1                    # This estimates the Autonomous_T1 BCTs_T1 covariance
d_Autonomous1 ~~ d_BCTs1                      # This estimates the d_Autonomous and d_BCTs covariance
'

fitBLCS_constrained <- lavaan::lavaan(BLCS_constrained, 
                          data = data_BLCS, 
                          estimator = 'mlr', 
                          fixed.x = FALSE,
                          group = "intervention",
                          missing = 'fiml')

lavaan::summary(fitBLCS_constrained, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)

lavaan::anova(fitBLCS, fitBLCS_constrained)

semPlot::semPaths(fitBLCS_constrained, 
                  what = "std",
                  ask = FALSE,
                  label.cex = .6, 
                  label.scale = FALSE,
                  edge.label.cex = 0.75, 
                  layout = "tree2",
                  intercepts = TRUE,
                  color = list(lat = viridis::viridis(3, begin = 0.3)[1], 
                               man = viridis::viridis(3, begin = 0.3)[2], 
                               int = viridis::viridis(3, begin = 0.3)[3]))


```

Next, we constrain the parameters which ought to differ across intervention and control groups, to see if model fit changes.

## Mean Autonomous change forced as equal 

First, constrain the intercept of the change score in Autonomous.

```{r}
data_BLCS <- df %>% dplyr::select(
  intervention,
  Autonomous_T1 = PA_autonomous_T1,
  Autonomous_T2 = PA_autonomous_T3,
  frqbct_T1 = PA_frqbct_T1,
  frqbct_T2 = PA_frqbct_T3,
  agrbct_T1 = PA_agrbct_T1,
  agrbct_T2 = PA_agrbct_T3) %>% 
  rowwise() %>% 
  dplyr::mutate(BCTs_T1 = mean(c(frqbct_T1, agrbct_T1), na.rm = TRUE),
                BCTs_T2 = mean(c(frqbct_T2, agrbct_T2), na.rm = TRUE)) %>% 
  dplyr::select(-contains("frq"), -contains("agr"))


#Fit the Bivariate Latent Change Score model to simulated data
BLCS_constrained_equalChanges_autonomous <- '

Autonomous_T2 ~ 1 * Autonomous_T1       # This parameter regresses Autonomous_T2 perfectly on Autonomous_T1
d_Autonomous1 =~ 1 * Autonomous_T2      # This defines the latent change score factor as measured perfectly by scores on Autonomous_T2
d_Autonomous1 ~ c(d_autint, d_autint) * 1                     # This estimates the intercept of the change score 
Autonomous_T1 ~  c(autint, autint) * 1  # This constrains the intercept of Autonomous_T1 to be identical across intervention and control groups 
Autonomous_T2 ~ 0 * 1                   # This constrains the intercept of Autonomous_T2 to 0

BCTs_T2 ~ 1 * BCTs_T1     # This parameter regresses BCTs_T2 perfectly on BCTs_T1
d_BCTs1 =~ 1 * BCTs_T2    # This defines the latent change score factor as measured perfectly by scores on BCTs_T2
BCTs_T2 ~ 0 * 1           # This line constrains the intercept of BCTs_T2 to 0
BCTs_T2 ~~ 0 * BCTs_T2    # This fixes the variance of the BCTs_T1 to 0  

d_Autonomous1 ~~  d_Autonomous1                     # This estimates the variance of the change scores
Autonomous_T1 ~~ c(autvar, autvar) * Autonomous_T1  # This estimates the variance of the Autonomous_T1 
Autonomous_T2 ~~ 0 * Autonomous_T2                  # This fixes the variance of the Autonomous_T2 to 0  

d_BCTs1 ~ 1                            # This estimates the intercept of the change score 
BCTs_T1 ~ c(bctint, bctint) * 1        # This estimates the intercept of BCTs_T1 
d_BCTs1 ~~ d_BCTs1                     # This estimates the variance of the change scores 
BCTs_T1 ~~ c(bctvar, bctvar) * BCTs_T1 # This estimates the variance of BCTs_T1 

d_BCTs1 ~ Autonomous_T1 + BCTs_T1       # This estimates the COG to NEU coupling parameter and the COG to COG self-feedback
d_Autonomous1 ~ BCTs_T1 + Autonomous_T1 # This estimates the NEU to COG coupling parameter and the NEU to NEU self-feedback

Autonomous_T1 ~~ c(autbct_cov, autbct_cov) * BCTs_T1                      # This estimates the Autonomous_T1 BCTs_T1 covariance
d_Autonomous1 ~~ d_BCTs1                      # This estimates the d_Autonomous and d_BCTs covariance
'

fitBLCS_constrained_equalChanges_autonomous <- lavaan::lavaan(BLCS_constrained_equalChanges_autonomous, 
                          data = data_BLCS, 
                          estimator = 'mlr', 
                          fixed.x = FALSE,
                          group = "intervention",
                          missing = 'fiml')

lavaan::summary(fitBLCS_constrained_equalChanges_autonomous, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)

lavaan::anova(fitBLCS, fitBLCS_constrained, fitBLCS_constrained_equalChanges_autonomous)

semPlot::semPaths(fitBLCS_constrained_equalChanges_autonomous, 
                  what = "std",
                  ask = FALSE,
                  label.cex = .6, 
                  label.scale = FALSE,
                  edge.label.cex = 0.75, 
                  layout = "tree2",
                  intercepts = TRUE,
                  color = list(lat = viridis::viridis(3, begin = 0.3)[1], 
                               man = viridis::viridis(3, begin = 0.3)[2], 
                               int = viridis::viridis(3, begin = 0.3)[3]))


```

We can see that model fit and out-of-sample prediction gets worse.

## Mean BCT change forced as equal 

Here we constrain the change in BCTs to be equal across groups:

```{r}
data_BLCS <- df %>% dplyr::select(
  intervention,
  Autonomous_T1 = PA_autonomous_T1,
  Autonomous_T2 = PA_autonomous_T3,
  frqbct_T1 = PA_frqbct_T1,
  frqbct_T2 = PA_frqbct_T3,
  agrbct_T1 = PA_agrbct_T1,
  agrbct_T2 = PA_agrbct_T3) %>% 
  rowwise() %>% 
  dplyr::mutate(BCTs_T1 = mean(c(frqbct_T1, agrbct_T1), na.rm = TRUE),
                BCTs_T2 = mean(c(frqbct_T2, agrbct_T2), na.rm = TRUE)) %>% 
  dplyr::select(-contains("frq"), -contains("agr"))


#Fit the Bivariate Latent Change Score model to simulated data
BLCS_constrained_equalChanges_bcts <- '

Autonomous_T2 ~ 1 * Autonomous_T1     # This parameter regresses Autonomous_T2 perfectly on Autonomous_T1
d_Autonomous1 =~ 1 * Autonomous_T2    # This defines the latent change score factor as measured perfectly by scores on Autonomous_T2
d_Autonomous1 ~ 1                     # This estimates the intercept of the change score 
Autonomous_T1 ~  c(autint, autint)*1  # This constrains the intercept of Autonomous_T1 to be identical across intervention and control groups 
Autonomous_T2 ~ 0 * 1                 # This constrains the intercept of Autonomous_T2 to 0

BCTs_T2 ~ 1 * BCTs_T1     # This parameter regresses BCTs_T2 perfectly on BCTs_T1
d_BCTs1 =~ 1 * BCTs_T2    # This defines the latent change score factor as measured perfectly by scores on BCTs_T2
BCTs_T2 ~ 0 * 1           # This line constrains the intercept of BCTs_T2 to 0
BCTs_T2 ~~ 0 * BCTs_T2    # This fixes the variance of the BCTs_T1 to 0  

d_Autonomous1 ~~  d_Autonomous1                     # This estimates the variance of the change scores
Autonomous_T1 ~~ c(autvar, autvar) * Autonomous_T1  # This estimates the variance of the Autonomous_T1 
Autonomous_T2 ~~ 0 * Autonomous_T2                  # This fixes the variance of the Autonomous_T2 to 0  

d_BCTs1 ~ c(d_bctint, d_bctint) * 1                            # This estimates the intercept of the change score 
BCTs_T1 ~ c(bctint, bctint) * 1        # This estimates the intercept of BCTs_T1 
d_BCTs1 ~~ d_BCTs1                     # This estimates the variance of the change scores 
BCTs_T1 ~~ c(bctvar, bctvar) * BCTs_T1 # This estimates the variance of BCTs_T1 

d_BCTs1 ~ Autonomous_T1 + BCTs_T1       # This estimates the COG to NEU coupling parameter and the COG to COG self-feedback
d_Autonomous1 ~ BCTs_T1 + Autonomous_T1 # This estimates the NEU to COG coupling parameter and the NEU to NEU self-feedback

Autonomous_T1 ~~ c(autbct_cov, autbct_cov) * BCTs_T1                      # This estimates the Autonomous_T1 BCTs_T1 covariance
d_Autonomous1 ~~ d_BCTs1                      # This estimates the d_Autonomous and d_BCTs covariance
'

fitBLCS_constrained_equalChanges_bcts <- lavaan::lavaan(BLCS_constrained_equalChanges_bcts, 
                          data = data_BLCS, 
                          estimator = 'mlr', 
                          fixed.x = FALSE,
                          group = "intervention",
                          missing = 'fiml')

lavaan::summary(fitBLCS_constrained_equalChanges_bcts, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)

lavaan::anova(fitBLCS, fitBLCS_constrained, fitBLCS_constrained_equalChanges_bcts)

semPlot::semPaths(fitBLCS_constrained_equalChanges_bcts, 
                  what = "std",
                  ask = FALSE,
                  label.cex = .6, 
                  label.scale = FALSE,
                  edge.label.cex = 0.75, 
                  layout = "tree2",
                  intercepts = TRUE,
                  color = list(lat = viridis::viridis(3, begin = 0.3)[1], 
                               man = viridis::viridis(3, begin = 0.3)[2], 
                               int = viridis::viridis(3, begin = 0.3)[3]))


```

## BCT -> Autonomous forced as equal

What if the intervention changed the coupling effect?

Here we constrain the coupling from BCTs to autonomous motivation:

```{r}
data_BLCS <- df %>% dplyr::select(
  intervention,
  Autonomous_T1 = PA_autonomous_T1,
  Autonomous_T2 = PA_autonomous_T3,
  frqbct_T1 = PA_frqbct_T1,
  frqbct_T2 = PA_frqbct_T3,
  agrbct_T1 = PA_agrbct_T1,
  agrbct_T2 = PA_agrbct_T3) %>% 
  rowwise() %>% 
  dplyr::mutate(BCTs_T1 = mean(c(frqbct_T1, agrbct_T1), na.rm = TRUE),
                BCTs_T2 = mean(c(frqbct_T2, agrbct_T2), na.rm = TRUE)) %>% 
  dplyr::select(-contains("frq"), -contains("agr"))


#Fit the Bivariate Latent Change Score model to simulated data
BLCS_constrained_eqCoupling_bctToAut <- '

Autonomous_T2 ~ 1 * Autonomous_T1     # This parameter regresses Autonomous_T2 perfectly on Autonomous_T1
d_Autonomous1 =~ 1 * Autonomous_T2    # This defines the latent change score factor as measured perfectly by scores on Autonomous_T2
d_Autonomous1 ~ 1                     # This estimates the intercept of the change score 
Autonomous_T1 ~  c(autint, autint)*1  # This constrains the intercept of Autonomous_T1 to be identical across intervention and control groups 
Autonomous_T2 ~ 0 * 1                 # This constrains the intercept of Autonomous_T2 to 0

BCTs_T2 ~ 1 * BCTs_T1     # This parameter regresses BCTs_T2 perfectly on BCTs_T1
d_BCTs1 =~ 1 * BCTs_T2    # This defines the latent change score factor as measured perfectly by scores on BCTs_T2
BCTs_T2 ~ 0 * 1           # This line constrains the intercept of BCTs_T2 to 0
BCTs_T2 ~~ 0 * BCTs_T2    # This fixes the variance of the BCTs_T1 to 0  

d_Autonomous1 ~~  d_Autonomous1                     # This estimates the variance of the change scores
Autonomous_T1 ~~ c(autvar, autvar) * Autonomous_T1  # This estimates the variance of the Autonomous_T1 
Autonomous_T2 ~~ 0 * Autonomous_T2                  # This fixes the variance of the Autonomous_T2 to 0  

d_BCTs1 ~ 1                            # This estimates the intercept of the change score 
BCTs_T1 ~ c(bctint, bctint) * 1        # This estimates the intercept of BCTs_T1 
d_BCTs1 ~~ d_BCTs1                     # This estimates the variance of the change scores 
BCTs_T1 ~~ c(bctvar, bctvar) * BCTs_T1 # This estimates the variance of BCTs_T1 

d_BCTs1 ~ Autonomous_T1 + BCTs_T1       # This estimates the COG to NEU coupling parameter and the COG to COG self-feedback
d_Autonomous1 ~ c(d_bctaut, d_bctaut) * BCTs_T1 + Autonomous_T1 # This estimates the NEU to COG coupling parameter and the NEU to NEU self-feedback

Autonomous_T1 ~~ c(autbct_cov, autbct_cov) * BCTs_T1                      # This estimates the Autonomous_T1 BCTs_T1 covariance
d_Autonomous1 ~~ d_BCTs1                      # This estimates the d_Autonomous and d_BCTs covariance
'

fitBLCS_constrained_eqCoupling_bctToAut <- lavaan::lavaan(BLCS_constrained_eqCoupling_bctToAut, 
                          data = data_BLCS, 
                          estimator = 'mlr', 
                          fixed.x = FALSE,
                          group = "intervention",
                          missing = 'fiml')

lavaan::summary(fitBLCS_constrained_eqCoupling_bctToAut, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)

lavaan::anova(fitBLCS, fitBLCS_constrained, fitBLCS_constrained_eqCoupling_bctToAut)

semPlot::semPaths(fitBLCS_constrained_eqCoupling_bctToAut, 
                  what = "std",
                  ask = FALSE,
                  label.cex = .6, 
                  label.scale = FALSE,
                  edge.label.cex = 0.75, 
                  layout = "tree2",
                  intercepts = TRUE,
                  color = list(lat = viridis::viridis(3, begin = 0.3)[1], 
                               man = viridis::viridis(3, begin = 0.3)[2], 
                               int = viridis::viridis(3, begin = 0.3)[3]))


```

## Autonomous -> BCT forced as equal

Here we constrain the coupling from autonomous motivation to BCTs:

```{r}
data_BLCS <- df %>% dplyr::select(
  intervention,
  Autonomous_T1 = PA_autonomous_T1,
  Autonomous_T2 = PA_autonomous_T3,
  frqbct_T1 = PA_frqbct_T1,
  frqbct_T2 = PA_frqbct_T3,
  agrbct_T1 = PA_agrbct_T1,
  agrbct_T2 = PA_agrbct_T3) %>% 
  rowwise() %>% 
  dplyr::mutate(BCTs_T1 = mean(c(frqbct_T1, agrbct_T1), na.rm = TRUE),
                BCTs_T2 = mean(c(frqbct_T2, agrbct_T2), na.rm = TRUE)) %>% 
  dplyr::select(-contains("frq"), -contains("agr"))


#Fit the Bivariate Latent Change Score model to simulated data
BLCS_constrained_eqCoupling_autToBct <- '

Autonomous_T2 ~ 1 * Autonomous_T1     # This parameter regresses Autonomous_T2 perfectly on Autonomous_T1
d_Autonomous1 =~ 1 * Autonomous_T2    # This defines the latent change score factor as measured perfectly by scores on Autonomous_T2
d_Autonomous1 ~ 1                     # This estimates the intercept of the change score 
Autonomous_T1 ~  c(autint, autint)*1  # This constrains the intercept of Autonomous_T1 to be identical across intervention and control groups 
Autonomous_T2 ~ 0 * 1                 # This constrains the intercept of Autonomous_T2 to 0

BCTs_T2 ~ 1 * BCTs_T1     # This parameter regresses BCTs_T2 perfectly on BCTs_T1
d_BCTs1 =~ 1 * BCTs_T2    # This defines the latent change score factor as measured perfectly by scores on BCTs_T2
BCTs_T2 ~ 0 * 1           # This line constrains the intercept of BCTs_T2 to 0
BCTs_T2 ~~ 0 * BCTs_T2    # This fixes the variance of the BCTs_T1 to 0  

d_Autonomous1 ~~  d_Autonomous1                     # This estimates the variance of the change scores
Autonomous_T1 ~~ c(autvar, autvar) * Autonomous_T1  # This estimates the variance of the Autonomous_T1 
Autonomous_T2 ~~ 0 * Autonomous_T2                  # This fixes the variance of the Autonomous_T2 to 0  

d_BCTs1 ~ 1                            # This estimates the intercept of the change score 
BCTs_T1 ~ c(bctint, bctint) * 1        # This estimates the intercept of BCTs_T1 
d_BCTs1 ~~ d_BCTs1                     # This estimates the variance of the change scores 
BCTs_T1 ~~ c(bctvar, bctvar) * BCTs_T1 # This estimates the variance of BCTs_T1 

d_BCTs1 ~ c(d_autbct, d_autbct) * Autonomous_T1 + BCTs_T1       # This estimates the COG to NEU coupling parameter and the COG to COG self-feedback
d_Autonomous1 ~ BCTs_T1 + Autonomous_T1 # This estimates the NEU to COG coupling parameter and the NEU to NEU self-feedback

Autonomous_T1 ~~ c(autbct_cov, autbct_cov) * BCTs_T1                      # This estimates the Autonomous_T1 BCTs_T1 covariance
d_Autonomous1 ~~ d_BCTs1                      # This estimates the d_Autonomous and d_BCTs covariance
'

fitBLCS_constrained_eqCoupling_autToBct <- lavaan::lavaan(BLCS_constrained_eqCoupling_autToBct, 
                          data = data_BLCS, 
                          estimator = 'mlr', 
                          fixed.x = FALSE,
                          group = "intervention",
                          missing = 'fiml')

lavaan::summary(fitBLCS_constrained_eqCoupling_autToBct, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)

lavaan::anova(fitBLCS, fitBLCS_constrained, fitBLCS_constrained_eqCoupling_autToBct)

semPlot::semPaths(fitBLCS_constrained_eqCoupling_autToBct, 
                  what = "std",
                  ask = FALSE,
                  label.cex = .6, 
                  label.scale = FALSE,
                  edge.label.cex = 0.75, 
                  layout = "tree2",
                  intercepts = TRUE,
                  color = list(lat = viridis::viridis(3, begin = 0.3)[1], 
                               man = viridis::viridis(3, begin = 0.3)[2], 
                               int = viridis::viridis(3, begin = 0.3)[3]))

```

## All previous constraints imposed at once

The information criteria seem to imply somewhat better out-of-sample prediction for each of the constraints introduced previously. Here we set all of them:

```{r}
data_BLCS <- df %>% dplyr::select(
  intervention,
  Autonomous_T1 = PA_autonomous_T1,
  Autonomous_T2 = PA_autonomous_T3,
  frqbct_T1 = PA_frqbct_T1,
  frqbct_T2 = PA_frqbct_T3,
  agrbct_T1 = PA_agrbct_T1,
  agrbct_T2 = PA_agrbct_T3) %>% 
  rowwise() %>% 
  dplyr::mutate(BCTs_T1 = mean(c(frqbct_T1, agrbct_T1), na.rm = TRUE),
                BCTs_T2 = mean(c(frqbct_T2, agrbct_T2), na.rm = TRUE)) %>% 
  dplyr::select(-contains("frq"), -contains("agr"))


#Fit the Bivariate Latent Change Score model to simulated data
BLCS_allConstraints <- '

Autonomous_T2 ~ 1 * Autonomous_T1     # This parameter regresses Autonomous_T2 perfectly on Autonomous_T1
d_Autonomous1 =~ 1 * Autonomous_T2    # This defines the latent change score factor as measured perfectly by scores on Autonomous_T2
d_Autonomous1 ~ c(d_autint, d_autint) * 1                     # This estimates the intercept of the change score 
Autonomous_T1 ~  c(autint, autint)*1  # This constrains the intercept of Autonomous_T1 to be identical across intervention and control groups 
Autonomous_T2 ~ 0 * 1                 # This constrains the intercept of Autonomous_T2 to 0

BCTs_T2 ~ 1 * BCTs_T1     # This parameter regresses BCTs_T2 perfectly on BCTs_T1
d_BCTs1 =~ 1 * BCTs_T2    # This defines the latent change score factor as measured perfectly by scores on BCTs_T2
BCTs_T2 ~ 0 * 1           # This line constrains the intercept of BCTs_T2 to 0
BCTs_T2 ~~ 0 * BCTs_T2    # This fixes the variance of the BCTs_T1 to 0  

d_Autonomous1 ~~  d_Autonomous1                     # This estimates the variance of the change scores
Autonomous_T1 ~~ c(autvar, autvar) * Autonomous_T1  # This estimates the variance of the Autonomous_T1 
Autonomous_T2 ~~ 0 * Autonomous_T2                  # This fixes the variance of the Autonomous_T2 to 0  

d_BCTs1 ~ c(d_bctint, d_bctint) * 1                            # This estimates the intercept of the change score 
BCTs_T1 ~ c(bctint, bctint) * 1        # This estimates the intercept of BCTs_T1 
d_BCTs1 ~~ d_BCTs1                     # This estimates the variance of the change scores 
BCTs_T1 ~~ c(bctvar, bctvar) * BCTs_T1 # This estimates the variance of BCTs_T1 

d_BCTs1 ~ c(d_autbct, d_autbct) * Autonomous_T1 + BCTs_T1       # This estimates the COG to NEU coupling parameter and the COG to COG self-feedback
d_Autonomous1 ~ c(d_bctaut, d_bctaut) * BCTs_T1 + Autonomous_T1 # This estimates the NEU to COG coupling parameter and the NEU to NEU self-feedback

Autonomous_T1 ~~ c(autbct_cov, autbct_cov) * BCTs_T1                      # This estimates the Autonomous_T1 BCTs_T1 covariance
d_Autonomous1 ~~ d_BCTs1                      # This estimates the d_Autonomous and d_BCTs covariance
'

fitBLCS_allConstraints <- lavaan::lavaan(BLCS_allConstraints, 
                          data = data_BLCS, 
                          estimator = 'mlr', 
                          fixed.x = FALSE,
                          group = "intervention",
                          missing = 'fiml')

lavaan::summary(fitBLCS_allConstraints, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)

lavaan::anova(fitBLCS, fitBLCS_constrained, fitBLCS_allConstraints)

semPlot::semPaths(fitBLCS_allConstraints, 
                  what = "std",
                  ask = FALSE,
                  label.cex = .6, 
                  label.scale = FALSE,
                  edge.label.cex = 0.75, 
                  layout = "tree2",
                  intercepts = TRUE,
                  color = list(lat = viridis::viridis(3, begin = 0.3)[1], 
                               man = viridis::viridis(3, begin = 0.3)[2], 
                               int = viridis::viridis(3, begin = 0.3)[3]))

```
